{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"strawberry-django-plus","text":"<p>Enhanced Strawberry integration with Django.</p> <p>Built on top of strawberry-django integration, enhancing its overall functionality.</p> <p> </p> <p>Warning</p> <p>All the extra features provided by this lib were contributed and merged directly into the official strawberry-graphql-django lib. Since then this lib is deprecated and the official integration should be used instead and development will continue there!</p> <p>If you were using this lib before, check out the migration guide for more information on how to migrate your code.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> All supported features by <code>strawberry</code> and <code>strawberry-django</code>.</li> <li> Query optimizer extension       that automatically optimizes querysets       (using <code>only</code>/<code>select_related</code>/<code>prefetch_related</code>) to solve graphql <code>N+1</code> problems, with support       for fragment spread, inline fragments, <code>@include</code>/<code>@skip</code> directives, prefetch merging, etc</li> <li> Django choices enums using       support for better enum typing (requires       django-choices-field)</li> <li> Permissioned resolvers       using schema directives, supporting both       django authentication system,       direct and per-object permission checking for backends that implement those (e.g.       django-guardian).</li> <li> Mutations for Django,       with CRUD support and automatic errors validation.</li> <li> Relay support       for queries, connections and input mutations, all integrated with django types directly.</li> <li> Django Debug Toolbar integration with graphiql to       display metrics like SQL queries</li> <li> Improved sync/async resolver that priorizes the model's cache to avoid have to use       sync_to_async       when not needed.</li> <li> A well typed and documented API.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install strawberry-django-plus\n</code></pre>"},{"location":"#how-to","title":"How to","text":"<p>You can now jump to the quickstart to learn how to use this lib.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Warning</p> <p>All the extra features provided by this lib were contributed and merged directly into the official strawberry-graphql-django lib. Since then this lib is deprecated and the official integration should be used instead.</p> <p>If you were using this lib before, check out the migration guide for more information on how to migrate your code.</p> <p>We use poetry to manage dependencies, to get started follow these steps:</p> <pre><code>git clone https://github.com/blb-ventures/strawberry-django-plus\ncd strawberry-django-plus\npoetry install\npoetry run pytest\n</code></pre> <p>This will install all the dependencies (including dev ones) and run the tests.</p>"},{"location":"contributing/#pre-commit","title":"Pre commit","text":"<p>We have a configuration for pre-commit, to add the hook run the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#docs-setup-and-local-server","title":"Docs setup and local server:","text":"<p>We use Material for MkDocs, you can read the documentation here</p> <pre><code>make serve-docs\n</code></pre>"},{"location":"debug-toolbar/","title":"Django debug toolbar","text":"<p>Warning</p> <p>All the extra features provided by this lib were contributed and merged directly into the official strawberry-graphql-django lib. Since then this lib is deprecated and the official integration should be used instead.</p> <p>If you were using this lib before, check out the migration guide for more information on how to migrate your code.</p> <p>Tip</p> <p>Since version 3.0.0 this feature was removed from this lib due to it being merged on strawberry-graphql-django, and should now be used from there. Check its docs for more information.</p> <p>This integration provides integration between the Django Debug Toolbar and <code>strawberry</code>, allowing it to display stats like <code>SQL Queries</code>, <code>CPU Time</code>, <code>Cache Hits</code>, etc for queries and mutations done inside the graphiql page.</p> <p>To use it, make sure you have the Django Debug Toolbar installed and configured, then change its middleware settings from:</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>To:</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"strawberry_django_plus.middlewares.debug_toolbar.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>Finally, ensure app <code>\"strawberry_django_plus\"</code> is added to your <code>INSTALLED_APPS</code> in Django settings.</p>"},{"location":"migration-guide/","title":"Migration guide","text":""},{"location":"migration-guide/#migrating-to-strawberry-django","title":"Migrating to Strawberry Django","text":"<p>All the extra features provided by this lib were contributed and merged directly into the official strawberry-graphql-django lib. Since then this lib is deprecated and the official integration should be used instead.</p> <p>Follow these steps to migrate your existing code:</p>"},{"location":"migration-guide/#1-required-dependencies","title":"1) Required dependencies","text":"<p>Make sure you have <code>strawberry-graphql-django&gt;=0.10.0</code> in your dependencies. After the migration is complete you can safely remove <code>strawberry-django-plus</code> from them.</p>"},{"location":"migration-guide/#2-replace-your-gql-aliases","title":"2) Replace your <code>gql.*</code> aliases","text":"<p>The <code>gql.*</code> alias should be replaces by their correct counterpart. For example:</p> <ul> <li><code>gql.type</code> -&gt; <code>strawberry.type</code></li> <li><code>gql.field</code> -&gt; <code>strawberry.field</code></li> <li><code>gql.django.type</code> -&gt; <code>strawberry.django.type</code> (or <code>strawberry_django.type</code>)</li> <li><code>gql.django.field</code> -&gt; <code>strawberry.django.field</code> (or <code>strawberry_django.field</code>)</li> </ul>"},{"location":"migration-guide/#3-relay-api-adjustments","title":"3) Relay API adjustments","text":"<p>The relay integration was from <code>v3.0</code> in this lib was ported \"as is\" to strawberry django, meaning that the <code>gql.*</code> step adjustment will also adjust the relay APIs.</p> <p>In case you are migrating from <code>v2.x</code>, check the <code>v3.0.0</code> migration guide below. You don't need to upgrade to <code>v3.0.0</code> first, but you can use it to help adjusting your relay code.</p> <p>If you were not using the relay integration, you can skip this step.</p>"},{"location":"migration-guide/#4-mutation-api-adjustments","title":"4) Mutation API adjustments","text":"<p>There are some differences to be aware for the mutations API:</p> <ol> <li><code>strawberry_django.mutation</code> and <code>strawberry_django.input_mutation</code> changed the    <code>handle_django_errors</code> argument default value from <code>True</code> to <code>False</code>. If you want    the old behaviour for all mutations without having to modify the argument by hand,    you can set the <code>\"MUTATIONS_DEFAULT_HANDLE_ERRORS\": True</code> in your    strawberry django settings</li> <li>CUD mutations are now based on strawberry django's ones. You should rename your    <code>create_mutation</code>/<code>update_mutation</code>/<code>delete_mutation</code> calls to    <code>create</code>/<code>update</code>/<code>delete</code> respectively.</li> <li>CUD mutations from strawberry django define the input field argument's name to    <code>data</code> by default. You can change it to <code>input</code> (this lib's argument name) by passing    <code>argument_name=\"input\"</code> to the mutation. If you want that name for all mutations    regardless, you can set the <code>\"MUTATIONS_DEFAULT_ARGUMENT_NAME\": \"input\"</code> in your    strawberry django settings</li> </ol>"},{"location":"migration-guide/#5-permissions-refactored-to-use-field-extensions","title":"5) Permissions refactored to use Field Extensions","text":"<p>Permission checking used to require including a \"Schema Directive Extension\" in your schema's extensions. That is not required anymore since the new implementation is based on the official \"Field Extensions\" support from strawberry.</p> <p>Most extensions have the same name, except for <code>HasRootPerm</code> and <code>HasSourcePerm</code> that were renamed like this:</p> <ul> <li><code>HasRootPerm</code> -&gt; <code>HasSourcePerm</code></li> <li><code>HasObjPerm</code> -&gt; <code>HasRetvalPerm</code></li> </ul> <p>To migrate, all you need to do is change the directive your were previously inserting in your field with the related extension. For example, the following code:</p> <pre><code>import strawberry\nfrom strawberry_django_plus import gql\nfrom strawberry_django_plus.permissions import IsAuthenticated, HasObjPerm\nfrom strawberry_django_plus.directives import SchemaDirectiveExtension\n\n@gql.type\nclass Query:\n    fruit: Fruit = gql.django.field(directives=[IsAuthenticated()])\n    fruit2: Fruit = gql.django.field(directives=[HasObjPerm(\"can_view_fruit\")])\n\nschema = strawberry.schema(\n    query=Query,\n    extensions=[\n        SchemaDirectiveExtension,\n    ],\n)\n</code></pre> <p>Can be migrated to:</p> <pre><code>import strawberry\nfrom strawberry_django.permissions import IsAuthenticated, HasRetvalPerm\n\n@strawberry.type\nclass Query:\n    fruit: Fruit = strawberry.django.field(extensions=[IsAuthenticated()])\n    fruit2: Fruit = strawberry.django.field(extensions=[HasRetvalPerm(\"can_view_fruit\")])\n\nschema = strawberry.schema(\n    query=Query,\n)\n</code></pre>"},{"location":"migration-guide/#6-typesfields-description-from-models-docstring-and-fields-help_text","title":"6) Types/Fields description from model's docstring and field's <code>help_text</code>","text":"<p>The ability to retrieve types/fields description directly from the model's docstring and/or field's <code>help_text</code> is available on strawberry django, but it is an opt-in feature.</p> <p>To enable those, you can set the <code>\"FIELD_DESCRIPTION_FROM_HELP_TEXT\": True</code> and <code>\"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\": True</code> in your strawberry django settings</p>"},{"location":"migration-guide/#7-enjoy","title":"7) Enjoy! \ud83d\ude0a","text":"<p>If you followed all those steps correctly, your code should be working just like it was before.</p> <p>Be sure to check strawberry django's documentation page to know more about all the feature it provides.</p> <p>Also, if you find any issues during your migration, be sure to open an issue at its repository.</p> <p>Don't forget you can also reach us in our discord page.</p>"},{"location":"migration-guide/#version-300","title":"Version 3.0.0","text":""},{"location":"migration-guide/#debug-toolbar-integration-moved-to-strawberry-graphql-django","title":"Debug toolbar integration moved to strawberry-graphql-django","text":"<p>The debug-toolbar-integration was merged on the official strawberry-graphql-django and should be used from there.</p> <p>If you were using the integration before, you need to change your <code>MIDDLEWARE</code> settings from:</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"strawberry_django_plus.middlewares.debug_toolbar.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>to:</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"strawberry_django.middlewares.debug_toolbar.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>Also make sure that you have <code>\"strawberry_django\"</code> added to your <code>INSTALLED_APPS</code> settings.</p>"},{"location":"migration-guide/#relay-integration-moved-to-strawberry-core","title":"Relay integration moved to strawberry core","text":"<p>The relay integration from this lib has been contributed and merged directly on strawberry core.</p> <p>It works almost the same as the one in this lib with a few differences. Be sure to check the strawberry's relay docs to know more about it.</p> <p>strawberry-django-plus has been updated to use that new official integration instead of the one provided by us, which has also been removed. If you were using it, there are a few adjustments that you need to do:</p> <ul> <li>Change your <code>relay.Connection[SomeType]</code> annotations to either   <code>relay.ListConnection[SomeType]</code> or <code>gql.django.ListConnectionWithTotalCount</code>.</li> </ul> <p><code>relay.Connection</code> is now an abstract class which you can inherit from it to implement your own pagination algorithm.</p> <p><code>relay.ListConnection</code> is a limit/offset implementation of <code>relay.Connection</code> that works the same way as this lib's one used to work, except for the fact that it doesn't include a <code>totalCount</code> field by default. For that reason we are providing a new <code>gql.django.ListConnectionWithTotalCount</code> which builds on top <code>relay.ListConnection</code> and includes a <code>totalCount</code> field, meaning it will actually produce the same schema and functionality as the old <code>Connection</code>.</p> <ul> <li>All fields annotated with a <code>Connection</code> needs to define be set to a relay field,   and any resolver decorated with <code>@relay.connection</code> should define the connection   type it returns.</li> </ul> <p>For example, you can migrate this code:</p> <pre><code>@gql.type\nclass Query:\n    some_conn: relay.Connection[SomeType]\n    some_django_conn: relay.Connection[SomeDjangoType] = gql.django.connection()\n\n    @gql.django.connection\n    def other_django_conn(self) -&gt; Iterable[SomeDjangoType]:\n        return SomeDjangoModel.objects.all()\n</code></pre> <p>By changing it to:</p> <pre><code>@gql.type\nclass Query:\n    some_conn: relay.Connection[SomeType] = relay.connection(resolver=some_resolver)\n    some_django_conn: relay.ListConnection[SomeDjangoType] = gql.django.connection()\n\n    @gql.django.connection(relay.ListConnection[SomeDjangoType])\n    def other_django_conn(self) -&gt; Iterable[SomeDjangoModel]:\n        return SomeDjangoModel.objects.all()\n</code></pre> <p>Note that the <code>other_django_conn</code> resolver's return type don't need to be set to an <code>Iterable[SomeDjangoType]</code>, because the connection type now is retrieved from the connection decorator. This means you can remove some useless <code>casts</code> for type checkers in those functions.</p> <ul> <li>All connection fields should define a resolver</li> </ul> <p>The new official integration enforces a resolver that returns an iterable/generator of items for all connection fields. This means that you either need to pass a <code>resolver</code> argument to <code>relay.connection()</code> or use it as a decorator on top of a resolver.</p> <p>When using <code>gql.django.connection()</code>, strawberry-django-plus will create a default resolver for you in case you didn't use it as a decorator on top of one. That default resolver works the same way as before, by returning a queryset of the model's queryset (e.g. <code>SomeDjangoModel.objects.all()</code>).</p> <ul> <li>All <code>Node</code> implemented types should define a <code>relay.NodeID</code> annotation</li> </ul> <p>The field that will be used to generate the <code>GlobalID</code> value for the type is now identified by annotating it with <code>relay.NodeID</code>. For example:</p> <pre><code>@strawberry.type\nclass SomeType:\n    my_id: relay.NodeID[int]\n</code></pre> <p>For django types, if you don't define any <code>relay.NodeID</code> annotation it will automatically use the model's primary key (the <code>pk</code> attr) as it. You can change it by annotation a different field instead. For example:</p> <pre><code>from django.db import models\nfrom strabwerry import relay\nfrom strawberry_django_plus import gql\n\n\nclass SomeDjangoModel(models.Model):\n    code = models.CharField(max_length=10, unique=True)\n\n\n@gql.django.type(SomeDjangoModel)\nclass SomeDjangoType(relay.Node):\n    ...\n\n\n@gql.django.type(SomeDjangoModel)\nclass SomeDjangoTypeWithCodeAsGlobalId(relay.Node):\n    code: relay.NodeID[str]\n</code></pre> <p>In this example, <code>SomeDjangoType.id</code> will generate its value from the model's primary key, but <code>SomeDjangoTypeWithCodeAsGlobalId</code> will generate it from <code>code</code>.</p> <p>Note that the field annotated as <code>relay.NodeID</code> is private, meaning it will not be exposed in the final schema (it is only used to generate the <code>id</code>).</p>"},{"location":"mutations/","title":"Mutations","text":"<p>Warning</p> <p>All the extra features provided by this lib were contributed and merged directly into the official strawberry-graphql-django lib. Since then this lib is deprecated and the official integration should be used instead.</p> <p>If you were using this lib before, check out the migration guide for more information on how to migrate your code.</p> <p>This library provides 3 CUD mutations for streamlining common create/update/delete operations and reducing boilerplate code. There is also a facility for creating custom mutations with automatic <code>ValidationError</code> support.</p>"},{"location":"mutations/#cud-mutations","title":"CUD mutations","text":"<ul> <li><code>gql.django.create_mutation</code>: Will create the model using the data from the given input,   returning a <code>types.OperationInfo</code> if it fails with all raised <code>ValidationError</code> data.</li> <li><code>gql.django.update_mutation</code>: Will update the model using the data from the given input,   returning a <code>types.OperationInfo</code> if it fails with all raised <code>ValidationError</code> data.</li> <li><code>gql.django.delete_mutation</code>: Will delete the model using the id from the given input,   returning a <code>types.OperationInfo</code> if it fails with all raised <code>ValidationError</code> data.</li> </ul> <p>A simple complete example would be:</p> <pre><code>from strawberry_django_plus import gql\n\n@gql.django.type(SomeModel)\nclass SomeModelType(gql.Node):\n    name: gql.auto\n\n@gql.django.input(SomeModel)\nclass SomeModelInput:\n    name: gql.auto\n\n\n@gql.django.partial(SomeModel)\nclass SomeModelInputPartial(gql.NodeInput):\n    name: gql.auto\n\n@gql.type\nclass Mutation:\n    create_model: SomeModelType = gql.django.create_mutation(SomeModelInput)\n    update_model: SomeModelType = gql.django.update_mutation(SomeModelInputPartial)\n    delete_model: SomeModelType = gql.django.delete_mutation(gql.NodeInput)\n</code></pre>"},{"location":"mutations/#extending-build-in-cud-mutations","title":"Extending build in CUD mutations","text":"<p>There might be the need to perform some pre or post validation before running the built-in mutations. A common use case is for example setting a model field based on the current request context.</p> <p>As the syntax is not completely straightforward at the moment an example is listed as follows.</p> <pre><code>from django.conf import settings\nfrom django.db import models\n\n# Django Model\nclass Asset(models.Model):\n    name = models.TextField(null=True, blank=True)\n    owner = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, null=True, blank=True)\n</code></pre> <p>The strawberry code uses a relay implementation but the concept should also work in a non-relay context.</p> <pre><code>from strawberry_django_plus.mutations import resolvers\n\n@gql.django.type(Asset)\nclass AssetNode(gql.relay.Node):\n    name: gql.auto\n    owner: UserNode\n\n@gql.django.partial(Asset)\nclass UpdateAssetInput(gql.NodeInput):\n    name: gql.auto\n\n@gql.type\nclass ModelMutation:\n\n    @gql.mutation\n    def update_asset(self, info: Info, input: UpdateAssetInput) -&gt; ModelNode:\n        data = vars(input)\n        node_id: gql.relay.GlobalID = data.pop('id')\n        asset: Asset = node_id.resolve_node(info, ensure_type=Asset)\n\n        if asset.owner != info.context.request.user:\n            raise PermissionError(\"You can only modify objects you own.\")\n\n        return resolvers.update(info, asset, resolvers.parse_input(info, data))\n</code></pre> <p>Important to note is that the input has to be converted via <code>vars</code> call. The concept is taken from the built-in mutation. You then need to call the <code>resolvers.update</code> function to mutate the model instance. The main benefit is that you keep all the validation and update logic from the built-in mutation.</p>"},{"location":"mutations/#custom-model-mutations","title":"Custom model mutations","text":"<p>It is possible to create custom model mutations with <code>gql.django.input_mutation</code>, which will automatically convert the arguments to an input type and mark the return value as a union between the type annotation and <code>types.OperationInfo</code>. The latter will be returned if the resolver raises <code>ValidationError</code>.</p> <p>For example:</p> <pre><code>from django.core.exceptions import ValidationError\nfrom strawberry_django_plus import gql\n\n@gql.type\nclass Mutation:\n    @gql.django.input_mutation\n    def set_model_name(self, info, id: GlobalID, name: str) -&gt; ModelType:\n        obj = id.resolve_node(info)\n        if obj.some_field == \"some_value\":\n            raise ValidationError(\"Cannot update obj with some_value\")\n\n        obj.name = name\n        obj.save()\n        return obj\n</code></pre>"},{"location":"query-optimizer/","title":"Query optimizer","text":"<p>Warning</p> <p>All the extra features provided by this lib were contributed and merged directly into the official strawberry-graphql-django lib. Since then this lib is deprecated and the official integration should be used instead.</p> <p>If you were using this lib before, check out the migration guide for more information on how to migrate your code.</p> <p>The automatic optimization is enabled by adding the <code>DjangoOptimizerExtension</code> to your strawberry's schema config.</p> <pre><code>import strawberry\nfrom strawberry_django_plus.optimizer import DjangoOptimizerExtension\n\nschema = strawberry.Schema(\n    Query,\n    extensions=[\n        # other extensions...\n        DjangoOptimizerExtension,\n    ]\n)\n</code></pre> <p>Now consider the following:</p> <p>Example</p> models <pre><code>        class Artist(models.Model):\n            name = models.CharField()\n\n\n        class Album(models.Moodel):\n            name = models.CharField()\n            release_date = models.DateTimeField()\n            artist = models.ForeignKey(\"Artist\", related_name=\"albums\")\n\n\n        class Song(models.Model):\n            name = model.CharField()\n            duration = models.DecimalField()\n            album = models.ForeignKey(\"Album\", related_name=\"songs\")\n        ```\n    === \"schema\"\n        ```python\n        from strawberry_django_plus import gql\n\n        @gql.django.type(Artist)\n        class ArtistType:\n            name: auto\n            albums: \"List[AlbumType]\"\n\n\n        @gql.django.type(Album)\n        class AlbumType:\n            name: auto\n            release_date: auto\n            artist: ArtistType\n            songs: \"List[SongType]\"\n\n\n        @gql.django.type(Song)\n        class SongType:\n            name: auto\n            duration: auto\n            album_type: AlbumType\n\n\n        @gql.type\n        class Query:\n            artist: Artist = gql.django.field()\n            songs: List[SongType] = gql.django.field()\n        ```\n\n    === \"query for the artist field\"\n        ```gql\n        query {\n          artist {\n            id\n            name\n            albums {\n              id\n              name\n              songs {\n                id\n                name\n              }\n            }\n          }\n        }\n        ```\n    === \"optimized queryset for the artist field\"\n        ```python\n        Artist.objects.all().only(\"id\", \"name\").prefetch_related(\n            Prefetch(\n                \"albums\",\n                queryset=Album.objects.all().only(\"id\", \"name\").prefetch_related(\n                    \"songs\",\n                    Song.objects.all().only(\"id\", \"name\"),\n                )\n            ),\n        )\n        ```\n    === \"query for the song field\"\n\n        ```gql\n        query {\n          song {\n            id\n            album\n            id\n            name\n            artist {\n              id\n              name\n              albums {\n                id\n                name\n                release_date\n              }\n            }\n          }\n        }\n\n        ```\n    === \"optimized queryset for the song field\"\n        ```python\n        Song.objects.all().only(\n            \"id\",\n            \"album\",\n            \"album__id\",\n            \"album__name\",\n            \"album__release_date\",  # Note about this below\n            \"album__artist\",\n            \"album__artist__id\",\n        ).select_related(\n            \"album\",\n            \"album__artist\",\n        ).prefetch_related(\n            \"album__artist__albums\",\n            Prefetch(\n                \"albums\",\n                Album.objects.all().only(\"id\", \"name\", \"release_date\"),\n            )\n        )\n        ```\n\n!!! Note\nEven though `album__release_date` field was not selected here, it got selected\nin the prefetch query later. Since Django caches known objects, we have to select it here or\nelse it would trigger extra queries latter.\n\n### Model property\n\nIt is possible to include hints for non-model fields using the field api or even our\n`@model_property` (or its cached variation, `@cached_model_property`) decorator on the model\nitself, for people who like to keep all the business logic at the model.\n\nFor example, the following will automatically optimize [`only`](https://docs.djangoproject.com/en/4.0/ref/models/querysets/#only) and [`select_related`](https://docs.djangoproject.com/en/4.0/ref/models/querysets/#django.db.models.query.QuerySet.select_related) if that\nfield gets selected:\n\n```python\nfrom strawberry_django_plus import gql\n\nclass Song(models.Model):\n    name = models.CharField()\n\n    @gql.model_property(only=[\"name\", \"album__name\"], select_related=[\"album\"])\n    def name_with_album(self) -&gt; str:\n        return f\"{self.album.name}: {self.name}\"\n\n@gql.django.type(Song)\nclass SongType:\n    name: auto\n    name_with_album: str\n</code></pre> <p>Another option would be to define that on the field itself:</p> <pre><code>@gql.django.type(Song)\nclass SongType:\n    name: auto\n    name_with_album: str = gql.django.field(\n        only=[\"name\", \"album__name\"],\n        select_related=[\"album\"],\n    )\n</code></pre>"},{"location":"quickstart/","title":"Quick start","text":"<p>Warning</p> <p>All the extra features provided by this lib were contributed and merged directly into the official strawberry-graphql-django lib. Since then this lib is deprecated and the official integration should be used instead.</p> <p>If you were using this lib before, check out the migration guide for more information on how to migrate your code.</p>"},{"location":"quickstart/#introduction","title":"Introduction","text":"<p>Since this lib has a long name, it does provide a shortcut called <code>gql</code> where all of strawberry's API and ours can be accessed.</p> <pre><code>from strawberry_django_plus import gql\n\n# All strawberry's base api can be found directly on gql, like:\ngql.type  # same as strawberry.type\ngql.field  # same as strawberry.field\n...\n\n# The strawberry-django API and our custom implementation can be found on gql.django, like:\ngql.django.type\ngql.django.field\n...\n\n# We also have a custom relay implementation in here:\ngql.relay\n</code></pre>"},{"location":"quickstart/#how-to","title":"How To","text":""},{"location":"quickstart/#django-choices-enums","title":"Django Choices Enums","text":"<p>Convert choices fields into GraphQL enums by using Django Choices Field extension.</p> <pre><code>from django_choices_field import TexChoicesField\n\nclass Song(models.Model):\n    class Genre(models.TextChoices):\n        ROCK = \"rock\", \"Rock'n'Roll\"\n        METAL = \"metal\", \"Metal\"\n        OTHERS = \"others\", \"Who Cares?\"\n\n    genre = TextChoicesField(choices_enum=Genre)\n</code></pre> <p>In that example, a new enum called <code>Genre</code> will be created and be used for queries and mutations.</p> <p>If you want to name it differently, decorate the class with <code>@gql.enum</code> with your preferred name so that this lib will not try to register it again.</p>"},{"location":"quickstart/#standard-django-choices-enums","title":"Standard django choices enums","text":"<p>Convert standard django choices fields into GraphQL enums by dynamically creating an Enum class based on choices This feature can be enable by defining <code>STRAWBERRY_DJANGO_GENERATE_ENUMS_FROM_CHOICES</code> setting to <code>True</code></p> <pre><code>class Song(models.Model):\n    GENRE_CHOICES = (\n        (\"rock\", \"Rock'n'Roll\"),\n        (\"metal\", \"Metal\"),\n        (\"others\", \"Who Cares?\"),\n    )\n\n    genre = models.CharField(choices=GENRE_CHOICES)\n</code></pre> <p>In that example, a new enum called <code>MyAppSongGenreEnum</code> will be dynamically created and be used for queries and mutations.</p> <p>Have in mind that this approach don't let you re-use the dynamically created enum elsewhere.</p>"},{"location":"quickstart/#permissioned-resolvers","title":"Permissioned resolvers","text":"<p>Permissioning is done using schema directives by applying them to the fields that requires permission checking.</p> <p>For example:</p> <pre><code>@strawberry.type\nclass SomeType:\n    login_required_field: RetType = strawberry.field(\n        # will check if the user is authenticated\n        directives=[IsAuthenticated()],\n    )\n    perm_required_field: OtherType = strawberry.field(\n        # will check if the user has `\"some_app.some_perm\"` permission\n        directives=[HasPerm(\"some_app.some_perm\")],\n    )\n    obj_perm_required_field: OtherType = strawberry.field(\n        # will check the permission for the resolved value\n        directives=[HasObjPerm(\"some_app.some_perm\")],\n    )\n</code></pre> <p>Available options are:</p> <ul> <li><code>IsAuthenticated</code>: Checks if the user is authenticated (<code>user.is_autenticated</code>)</li> <li><code>IsStaff</code>: Checks if the user is a staff member (<code>user.is_staff</code>)</li> <li><code>IsSuperuser</code>: Checks if the user is a superuser (<code>user.is_superuser</code>)</li> <li><code>HasPerm(perms: str, list[str], any: bool = True)</code>: Checks if the user has any or all of   the given permissions (<code>user.has_perm(perm)</code>)</li> <li><code>HasRootPerm(perms: str | list[str], any: bool = True)</code>: Checks if the user has any or all   of the given permissions for the root of that field (<code>user.has_perm(perm, root)</code>)</li> <li><code>HasObjPerm(perms: str | list[str], any: bool = True)</code>: Resolves the retval and then   checks if the user has any or all of the given permissions for that specific value   (<code>user.has_perm(perm, retval)</code>). Note that if the return value is a list, this directive   will filter the return value, removing objects that fails the check (check below for more   information regarding other possibilities).</li> </ul> <p>There are some important notes regarding how the directives handle the return value:</p> <ul> <li>If the user passes the check, the retval is returned normally</li> <li>If the user fails the check:</li> <li>If the return type was <code>Optional</code>, it returns <code>None</code></li> <li>If the return type was a <code>List</code>, it returns an empty list</li> <li>If the return type was a relay <code>Connection</code>, it returns an empty <code>Connection</code></li> <li>If the field is a union with <code>types.OperationInfo</code> or <code>types.OperationMessage</code>, that type     is returned with a kind of <code>PERMISSION</code>, explaining why the user doesn't have permission     to resolve that field.</li> <li>Otherwise, it raises a <code>PermissionError</code> for that resolver, which will be available at     the result's <code>errors</code> field.</li> </ul> <p>Note that since <code>strawberry</code> doesn't support resolvers for schema directives, it is necessary to use this lib's custom extension that handles the resolution of those and any other custom defined schema directive inherited from <code>strawberry_django_plus.directives.SchemaDirectiveResolver</code>:</p> <pre><code>import strawberry\nfrom strawberry_django_plus.directives import SchemaDirectiveExtension\n\nschema = strawberry.Schema(\n    Query,\n    extensions=[\n        SchemaDirectiveExtension,\n        # other extensions...\n    ]\n)\n</code></pre>"},{"location":"quickstart/#relay-support","title":"Relay Support","text":"<p>Warning</p> <p>Since version 3.0.0 the relay integration from this lib has been contributed and merged directly on strawberry core. Check its docs for more information on how to use it and/or the migration guide to know how to migrate your code from the older implementation.</p> <p>You can use the official strawberry relay integration directly with django types like this:</p> <pre><code>from strawberry_django_plus import gql\n\n\nclass Fruit(models.Model):\n    ...\n\n\n@gql.django.type(Fruit)\nclass FruitType(gql.relay.Node):\n    ...\n\n\n@gql.type\nclass Query:\n    some_model_conn: gql.relay.ListConnection[FruitType] = gql.django.connection()\n\n    @gql.django.connection(gql.relay.ListConnection[FruitType])\n    def some_model_conn_with_resolver(self, root: SomeModel) -&gt; models.QuerySet[SomeModel]:\n        return SomeModel.objects.all()\n</code></pre> <p>In this example, <code>some_model_conn</code> will automatically add a resolver that returns <code>SomeModel.objects.all()</code> for you.</p> <p>You can also define your own custom resolver like <code>some_model_conn_with_resolver</code> and it will be used instead. You can use this to filter the base <code>QuerySet</code> that will be used for pagination. Also note that you can add extra arguments in that resolver, and they will be included in the final field.</p> <p>You can also define your own custom connection type to add extra fields or customize the pagination algorithm. This libs provides a custom connection type that adds an extra field to retrieve the <code>totalCount</code> of the connection, and can be used like this:</p> <pre><code>some_model_conn: gql.django.ListConnectionWithTotalCount[FruitType] = gql.django.connection()\n</code></pre>"}]}